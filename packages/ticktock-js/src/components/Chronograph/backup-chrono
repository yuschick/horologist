import content from '../../content';
import { getDOMElementRotateValue, rotate, setupTriggerEvents } from '../../utils';
import { WatchSettings } from '../Watch';
import { ChronographClass, ChronographOptions, ResetProps } from './Chronograph.types';

/*
 * The chronograph complication requires a buttons and hands object
 * the buttons object contains the start and reset buttons which control the hands
 * The hands are designed and used to indicate tenth seconds, seconds, and minutes
 * for timing events. Flyback and Split-Second (rattrapante) functionality is supported for timing laps.
 *
 * MONO-PUSHER
 *  READY STATE
 *      Pusher 1: Go to ACTIVE STATE
 *  ACTIVE STATE
 *      Pusher 1: Go to PAUSED STATE
 *  PAUSED STATE
 *      Pusher 1: Go to READY STATE
 *
 *
 * DUAL PUSHER - STANDARD
 *  READY STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *  ACTIVE STATE
 *      Pusher 1 - Go to PAUsED STATE
 *      Pusher 2 - Go to READY STATE
 *  PAUSED STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Go to READY STATE
 *
 *
 * DUAL PUSHER - FLYBACK
 *  READY STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *  ACTIVE STATE
 *      Pusher 1 - Go to PAUsED STATE
 *      Pusher 2 - Resets all hands, stay in ACTIVE STATE
 *  PAUSED STATE
 *      Pushed 1 - Go to ACTIVE STATE
 *      Pusher 2 - Go to READY STATE
 *
 *
 * DUAL PUSHER - RATTRAPANTE
 *  READY STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *  ACTIVE STATE
 *      Pusher 1 - Go to PAUSED STATE
 *      Pusher 2 - Go to SPLIT SET STATE
 *  SPLIT SET STATE
 *      Pusher 1 - Go to PAUSED STATE
 *      Pusher 2 - Leave SPLIT SET STATE, Remain in ACTIVE STATE
 *  PAUSED STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pushed 2 - Go to READY STATE
 *  PAUSED STATE & SPLIT SET STATE
 *      Pusher 1 - Non-Split hands go to ACTIVE STATE, Split hands stay in SPLIT SET STATE
 *      Pusher 2 - Go to READY STATE
 *
 *
 * DUAL PUSHER - FLYBACK & RATTRAPANTE
 *  READY STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *  ACTIVE STATE
 *      Pusher 1 - Go to PAUSED STATE
 *      Pusher 2 - Go to ACTIVE SPLIT SET STATE, RESET STATE (FLYBACK)
 *  ACTIVE STATE & SPLIT SET STATE
 *      Pusher 1 - Go to PAUSED STATE
 *      Pusher 2 - Leave SPLIT SET STATE (RESYNC HANDS), Remain in ACTIVE STATE
 *  PAUSED STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pushed 2 - Go to READY STATE
 *  PAUSED STATE & SPLIT SET STATE
 *      Pusher 1 - Non-Split hands go to ACTIVE STATE, Split hands stay in SPLIT SET STATE
 *      Pusher 2 - Go to READY STATE
 *
 * TRI PUSHER - STANDARD
 *  READY STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *      Pusher 3 - Nothing
 *  ACTIVE STATE
 *      Pusher 1 - Go to PAUsED STATE
 *      Pusher 2 - Go to READY STATE
 *      Pusher 3 - Nothing
 *  PAUSED STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Go to READY STATE
 *      Pusher 3 - Nothing
 *
 *
 * TRI PUSHER - FLYBACK
 *  READY STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *      Pusher 3 - Nothing
 *  ACTIVE STATE
 *      Pusher 1 - Go to PAUsED STATE
 *      Pusher 2 - Go to RESET STATE, stay in ACTIVE STATE
 *      Pusher 3 - Nothing
 *  PAUSED STATE
 *      Pushed 1 - Go to ACTIVE STATE
 *      Pusher 2 - Go to READY STATE
 *      Pusher 3 - Nothing
 *
 *
 * TRI PUSHER - RATTRAPANTE
 *  READY STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *      Pusher 3 - Nothing
 *  ACTIVE STATE
 *      Pusher 1 - Go to PAUSED STATE
 *      Pusher 2 - Go to SPLIT SET STATE
 *      Pusher 3 - Nothing
 *  PAUSED STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *      Pusher 3 . Go to READY STATE
 *  PAUSED STATE WITH SPLIT SET STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Resync all hands, stay in PAUSED STATE
 *      Pusher 3 - Go to READY STATE
 *  SPIT SET STATE
 *      Pusher 1 - Go to PAUSED STATE
 *      Pusher 2 - Resync all hands, stay in ACTIVE STATE
 *      Pusher 3 - Nothing
 *
 *
 * TRI PUSHER - FLYBACK & RATTRAPANTE
 *  READY STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *      Pusher 3 - Nothing
 *  ACTIVE STATE
 *      Pusher 1 - Go to PAUSED STATE
 *      Pusher 2 - Go to SPLIT SET STATE
 *      Pusher 3 - Go to RESET STATE (FLYBACK)
 *  PAUSED STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Nothing
 *      Pusher 3 - Go to READY STATE
 *  PAUSED STATE WITH SPLIT SET STATE
 *      Pusher 1 - Go to ACTIVE STATE
 *      Pusher 2 - Resync all hands, stay in PAUSED STATE
 *      Pusher 3 - Go to READY STATE
 *  ACTIVE STATE WITH SPLIT SET STATE
 *      Pusher 1 - Go to PAUSED STATE
 *      Pusher 2 - Resync all hands, stay in ACTIVE STATE
 *      Pusher 3 - Go to RESET STATE (FLYBACK)
 */
export class Chronograph implements ChronographClass {
    hands: {
        tenths?: HTMLElement | null;
        seconds: HTMLElement | null;
        minutes: HTMLElement | null;
        hours?: HTMLElement | null;
        split?: {
            seconds?: HTMLElement | null;
            minutes?: HTMLElement | null;
            hours?: HTMLElement | null;
        };
    };
    hasError: boolean;
    iterationCount: number;
    interval?: ReturnType<typeof setInterval>;
    options: ChronographOptions;
    pushers: {
        mono: HTMLElement | null;
        dual?: HTMLElement | null;
        tri?: HTMLElement | null;
    };
    settings: WatchSettings;
    state: {
        isActive: boolean;
        isPaused: boolean;
        isReady: boolean;
        isReset: boolean;
        isSplitSet: boolean;
    };
    type: {
        isFlyback?: boolean;
        isMonoPusher?: boolean;
        isDualPusher?: boolean;
        isTriPusher?: boolean;
        isSplit?: boolean;
        isSingleSplit?: boolean;
        isDoubleSplit?: boolean;
        isTripleSplit?: boolean;
    };

    constructor(options: ChronographOptions, settings: WatchSettings) {
        this.options = options;
        this.hands = {
            tenths: this.options.hands.tenths
                ? document.getElementById(this.options.hands.tenths)
                : undefined,
            seconds: document.getElementById(this.options.hands.seconds),
            minutes: document.getElementById(this.options.hands.minutes),
            hours: this.options.hands.hours
                ? document.getElementById(this.options.hands.hours)
                : undefined,
            split: {
                seconds: this.options.hands.rattrapante?.seconds
                    ? document.getElementById(this.options.hands.rattrapante?.seconds)
                    : undefined,
                minutes: this.options.hands.rattrapante?.minutes
                    ? document.getElementById(this.options.hands.rattrapante?.minutes)
                    : undefined,
                hours: this.options.hands.rattrapante?.hours
                    ? document.getElementById(this.options.hands.rattrapante?.hours)
                    : undefined,
            },
        };
        this.pushers = {
            mono: document.getElementById(this.options.pushers.mono),
            dual: this.options.pushers.dual
                ? document.getElementById(this.options.pushers.dual)
                : undefined,
            tri: this.options.pushers.tri
                ? document.getElementById(this.options.pushers.tri)
                : undefined,
        };
        this.iterationCount = 1; // This increments each interval to determine when seconds/minutes/hours hands are to be rotated
        this.settings = settings;
        this.type = {};

        this.state = {
            isActive: false,
            isPaused: false,
            isReady: true,
            isReset: true,
            isSplitSet: false,
        };

        this.hasError = false;
        this.errorChecking();

        this.determineChronographType();
    }

    /*
     * Apply the event listeners to each of the chronograph pushers
     */
    bindEvents() {
        setupTriggerEvents(
            {
                activeClass: this.settings.activeClass,
                element: this.pushers.mono as HTMLElement,
            },
            () => {
                if (this.type.isMonoPusher) {
                    if (this.state.isReady) {
                        this.moveToActiveState();
                    } else if (this.state.isActive) {
                        this.moveToPausedState();
                    } else if (this.state.isPaused) {
                        this.moveToReadyState();
                    }
                }

                if (this.type.isDualPusher) {
                    if (this.state.isReady || this.state.isPaused) {
                        this.moveToActiveState();
                    } else if (this.state.isActive) {
                        this.moveToPausedState();
                    }
                }

                if (this.type.isTriPusher) {
                    if (this.state.isReady) {
                        this.moveToActiveState();
                    } else if (this.state.isPaused) {
                        this.clearInterval();
                        this.moveToReadyState();
                    }
                }
            },
        );

        if (!this.pushers.dual) return;

        setupTriggerEvents(
            {
                activeClass: this.settings.activeClass,
                element: this.pushers.dual,
            },
            () => {
                // DUAL PUSHER FUNCTIONALITY
                if (this.type.isDualPusher) {
                    if (this.type.isSplit) {
                        if (this.type.isFlyback && this.state.isActive) {
                            this.moveToSplitState();
                            this.resetHands({ splitReset: false });
                        }

                        if (this.type.isFlyback && this.state.isPaused) {
                            this.moveToReadyState();
                        }

                        if (this.state.isActive) {
                            if (this.state.isSplitSet) {
                                this.moveToSplitResetState();
                            } else {
                                this.moveToSplitState();
                            }
                        }
                    }

                    if (this.type.isFlyback) {
                        this.resetHands();
                    } else {
                        if (this.state.isPaused || this.state.isActive) {
                            this.moveToReadyState();
                        }
                    }
                }

                // TRI PUSHER FUNCTIONALITY
                if (this.type.isTriPusher) {
                    if (this.type.isFlyback) {
                        this.resetHands();
                    }

                    if (this.type.isSplit) {
                        if (this.state.isActive && !this.state.isSplitSet) {
                            this.moveToSplitState();
                        } else if (this.state.isSplitSet) {
                            this.moveToSplitResetState();
                        }
                    }
                }
            },
        );

        if (!this.pushers.tri) return;

        setupTriggerEvents(
            {
                activeClass: this.settings.activeClass,
                element: this.pushers.tri,
            },
            () => {
                if (this.state.isActive) {
                    this.moveToPausedState();
                } else if (this.state.isPaused) {
                    this.moveToActiveState();
                }
            },
        );
    }

    /*
     * Clear the Chronograph interval to pause all functionality
     */
    clearInterval() {
        clearInterval(this.interval);
        this.interval = undefined;
    }

    /*
     * Based on the pushers provided to the Chronograph,
     * set the chronograph type property on the class.
     */
    determineChronographType() {
        if (this.options.pushers.mono && !this.options.pushers.dual && !this.options.pushers.tri) {
            this.type.isMonoPusher = true;
            this.type.isDualPusher = false;
            this.type.isTriPusher = false;
        }

        if (this.options.pushers.mono && this.options.pushers.dual && !this.options.pushers.tri) {
            this.type.isMonoPusher = false;
            this.type.isDualPusher = true;
            this.type.isTriPusher = false;
        }

        if (this.options.pushers.mono && this.options.pushers.dual && this.options.pushers.tri) {
            this.type.isMonoPusher = false;
            this.type.isDualPusher = false;
            this.type.isTriPusher = true;
        }

        if (this.options.hands.rattrapante?.seconds) {
            this.type.isSingleSplit = true;
            this.type.isSplit = true;
        }

        if (this.options.hands.rattrapante?.minutes) {
            this.type.isDoubleSplit = true;
            this.type.isSplit = true;
        }

        if (this.options.hands.rattrapante?.hours) {
            this.type.isTripleSplit = true;
            this.type.isSplit = true;
        }

        if (this.options.flyback) {
            this.type.isFlyback = true;
        }
    }

    /*
     * @return boolean
     * Check for any critical errors within the setup of the complication
     * and set this.hasError accordingly
     */
    errorChecking() {
        this.hasError = false;

        if (!this.pushers.mono) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.mono_pusher_not_found);
        }
        if (this.options.pushers.dual && !this.pushers.dual) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.dual_pusher_not_found);
        }
        if (this.options.pushers.tri && !this.pushers.tri) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.tri_pusher_not_found);
        }
        if (this.options.pushers.tri && !this.options.pushers.dual) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.incompatible_pushers);
        }

        if (this.options.hands.tenths && !this.hands.tenths) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.tenth_seconds_hand_not_found);
        }
        if (!this.hands.seconds) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.seconds_hand_not_found);
        }
        if (!this.hands.minutes) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.minutes_hand_not_found);
        }
        if (this.options.hands.hours && !this.hands.hours) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.hours_hand_not_found);
        }
        if (this.options.hands.rattrapante?.seconds && !this.hands.split?.seconds) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.split_seconds_hand_not_found);
        }
        if (this.options.hands.rattrapante?.minutes && !this.hands.split?.minutes) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.split_minutes_hand_not_found);
        }
        if (this.options.hands.rattrapante?.hours && !this.hands.split?.hours) {
            this.hasError = true;
            throw new Error(content.chronograph.errors.split_hours_hand_not_found);
        }

        return this.hasError;
    }

    /*
     * If no errors are thrown, start the complication
     */
    init() {
        if (this.hasError) return;
        this.bindEvents();
    }

    /*
     * Active State is when the Chronograph is running.
     * Set properties and intervals to start the Chronograph
     */
    moveToActiveState() {
        this.state.isActive = true;
        this.state.isPaused = false;
        this.state.isReady = false;
        this.startInterval();
    }

    /*
     * Paused State is when the Chronograph is stopped while running, but not reset
     * Adjust properties and intervals, but do not reset hands
     */
    moveToPausedState() {
        this.state.isActive = false;
        this.state.isPaused = true;
        this.state.isReady = false;
        this.clearInterval();
    }

    /*
     * Ready State is when the Chronograph at its starting positions.
     * Reset all properties, intervals, and hands
     */
    moveToReadyState() {
        this.state.isActive = false;
        this.state.isPaused = false;
        this.state.isReady = true;
        this.state.isSplitSet = false;
        this.iterationCount = 1;
        this.resetHands();
    }

    /*
     * Split State is when a rattrapante chronograph has paused
     * its split hands.
     */
    moveToSplitState() {
        this.state.isSplitSet = true;
    }

    /*
     * Split State is when a rattrapante chronograph has paused
     * its split hands.
     */
    moveToSplitResetState() {
        this.state.isSplitSet = false;

        if (this.hands.split?.seconds && this.hands.seconds) {
            const currentHandPosition = getDOMElementRotateValue(this.hands.seconds);
            rotate({ element: this.hands.split.seconds, value: currentHandPosition });
        }

        if (this.hands.split?.minutes && this.hands.minutes) {
            const currentHandPosition = getDOMElementRotateValue(this.hands.minutes);
            rotate({ element: this.hands.split.minutes, value: currentHandPosition });
        }

        if (this.hands.split?.hours && this.hands.hours) {
            const currentHandPosition = getDOMElementRotateValue(this.hands.hours);
            rotate({ element: this.hands.split.hours, value: currentHandPosition });
        }
    }

    /*
     * Reset all hands back to their starting positions
     */
    resetHands(props?: ResetProps) {
        this.state.isReset = true;
        this.state.isSplitSet = !props?.splitReset || false;
        this.rotateHoursHand({ reset: true, splitReset: props?.splitReset });
        this.rotateMinutesHand({ reset: true, splitReset: props?.splitReset });
        this.rotateSecondsHand({ reset: true, splitReset: props?.splitReset });
        this.rotateSubSecondsHand({ reset: true, splitReset: props?.splitReset });
    }

    /*
     * Handle rotating the hours hand
     */
    rotateHoursHand(props?: ResetProps) {
        // Can cast here since error checking has passed
        const element = this.hands.hours as HTMLElement;
        const splitElement = this.hands.split?.hours;

        if (props?.reset) {
            rotate({ element, value: 0 });

            if (this.type.isTripleSplit) {
                rotate({ element: splitElement as HTMLElement, value: 0 });
            }
        } else {
            /*
             * If a tenths hand exists, the interval is 100ms, not 1000ms
             * This means, the minutes hand should only rotate every 600th iteration.
             * If no tenths hand exists, the interval is 1000ms, so rotate every 60th iteration
             */
            if (this.hands.tenths && this.iterationCount % 600 !== 0) return;
            if (this.iterationCount % 60 !== 0) return;
            // Most chronographs record up to 12 hours
            // Each hour broken into 60 increments
            const increment = 360 / 12 / 60; // 0.5deg

            const currentRotation = getDOMElementRotateValue(element);
            let value = currentRotation + increment;

            if (value >= 360) {
                console.info(
                    "ðŸ¥³ðŸŽ‰ The chronograph has run for 12 hours. That's a binge even Netflix would be jealous of. But for everybody's sake, we're putting an end to this.",
                );
                this.clearInterval();
                this.moveToReadyState();
            } else {
                rotate({ element, value });
            }

            if (this.type.isTripleSplit && !this.state.isSplitSet) {
                rotate({ element: splitElement as HTMLElement, value });
            }
        }
    }

    /*
     * Handle rotating the minutes hand
     */
    rotateMinutesHand(props?: ResetProps) {
        // Can cast here since error checking has passed
        const element = this.hands.minutes as HTMLElement;
        const splitElement = this.hands.split?.minutes;

        if (props?.reset) {
            rotate({ element, value: 0 });

            if (this.type.isDoubleSplit) {
                rotate({ element: splitElement as HTMLElement, value: 0 });
            }
        } else {
            /*
             * If a tenths hand exists, the interval is 100ms, not 1000ms
             * This means, the minutes hand should only rotate every 600th iteration.
             * If no tenths hand exists, the interval is 1000ms, so rotate every 60th iteration
             */
            if (this.hands.tenths && this.iterationCount % 600 !== 0) return;
            if (this.iterationCount % 60 !== 0) return;

            const increment = 360 / 60;
            const currentRotation = getDOMElementRotateValue(element);
            let value = currentRotation + increment;

            if (value >= 360) {
                value -= 360;
            }

            rotate({ element, value });

            if (this.type.isDoubleSplit && !this.state.isSplitSet) {
                rotate({ element: splitElement as HTMLElement, value });
            }
        }
    }

    /*
     * Handle rotating the seconds hand
     */
    rotateSecondsHand(props?: ResetProps) {
        // Can cast here since error checking has passed
        const element = this.hands.seconds as HTMLElement;
        const splitElement = this.hands.split?.seconds;

        if (props?.reset) {
            rotate({ element, value: 0 });

            if (this.type.isSingleSplit) {
                rotate({ element: splitElement as HTMLElement, value: 0 });
            }
        } else {
            /*
             * If a tenths hand exists, the interval is 100ms, not 1000ms
             * This means, the seconds hand should only rotate every tenth iteration.
             * If no tenths hand exists, the interval is 1000ms, so rotate each iteration
             */
            if (this.hands.tenths && this.iterationCount % 10 !== 0) return;

            const increment = 360 / 60;
            const currentRotation = getDOMElementRotateValue(element);
            let value = currentRotation + increment;

            if (value >= 360) {
                value -= 360;
            }

            rotate({ element, value });

            if (this.type.isSingleSplit && !this.state.isSplitSet) {
                rotate({ element: splitElement as HTMLElement, value });
            }
        }
    }

    /*
     * Handle rotating the tenths-seconds hand
     */
    rotateSubSecondsHand(props?: ResetProps) {
        // Can cast here since error checking has passed
        const element = this.hands.tenths as HTMLElement;

        if (props?.reset) {
            rotate({ element, value: 0 });
        } else {
            const increment = 360 / 600;
            const currentRotation = getDOMElementRotateValue(element);
            let value = currentRotation + increment;

            if (value >= 360) {
                value -= 360;
            }

            rotate({ element, value });
        }
    }

    /*
     * Start the chronograph interval which controls the whole complication
     */
    startInterval() {
        this.interval = setInterval(
            () => {
                if (this.state.isReset) this.state.isReset = false;
                if (this.hands.tenths) this.rotateSubSecondsHand();
                if (this.hands.hours) this.rotateHoursHand();

                this.rotateSecondsHand();
                this.rotateMinutesHand();

                this.iterationCount++;
            },
            this.options.hands.tenths ? 100 : 1000,
        );
    }
}
